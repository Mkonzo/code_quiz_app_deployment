{
  "questions": [
    {
      "id": "py_hard_1",
      "question": "What is the time complexity of this function?",
      "codeSnippet": "def find_pairs(arr):\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if arr[i] + arr[j] == 10:\n                print(i, j)",
      "options": ["O(n)", "O(n log n)", "O(n²)", "O(2n)"],
      "correctAnswer": 2,
      "explanation": "Nested loops both iterating through the array result in O(n²) time complexity. Each element is compared with every other element.",
      "type": "complexity",
      "language": "python",
      "difficulty": "hard",
      "points": 30,
      "timeLimit": 30,
      "category": "Algorithm Complexity"
    },
    {
      "id": "py_hard_2",
      "question": "What will this code output?",
      "codeSnippet": "def gen():\n    yield 1\n    yield 2\n    yield 3\ng = gen()\nprint(next(g))\nprint(next(g))",
      "options": ["1 1", "1 2", "2 3", "Error"],
      "correctAnswer": 1,
      "explanation": "Generators use yield to produce values lazily. Each call to next() resumes execution and returns the next yielded value. First call returns 1, second returns 2.",
      "type": "output",
      "language": "python",
      "difficulty": "hard",
      "points": 30,
      "timeLimit": 30,
      "category": "Generators"
    },
    {
      "id": "py_hard_3",
      "question": "What is the output?",
      "codeSnippet": "class Meta(type):\n    def __new__(cls, name, bases, dct):\n        dct['x'] = 10\n        return super().__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=Meta):\n    pass\n\nprint(MyClass.x)",
      "options": ["Error", "10", "None", "0"],
      "correctAnswer": 1,
      "explanation": "Metaclasses control class creation. The Meta metaclass adds an 'x' attribute with value 10 to MyClass during creation.",
      "type": "output",
      "language": "python",
      "difficulty": "hard",
      "points": 30,
      "timeLimit": 30,
      "category": "Metaclasses"
    },
    {
      "id": "py_hard_4",
      "question": "What will be printed?",
      "codeSnippet": "def decorator(func):\n    def wrapper(*args):\n        return func(*args) * 2\n    return wrapper\n\n@decorator\ndef add(a, b):\n    return a + b\n\nprint(add(2, 3))",
      "options": ["5", "10", "Error", "None"],
      "correctAnswer": 1,
      "explanation": "The decorator wraps the add function and multiplies its result by 2. add(2, 3) returns 5, which is then multiplied by 2 to get 10.",
      "type": "output",
      "language": "python",
      "difficulty": "hard",
      "points": 30,
      "timeLimit": 30,
      "category": "Decorators"
    },
    {
      "id": "py_hard_5",
      "question": "What is the space complexity?",
      "codeSnippet": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)",
      "options": ["O(1)", "O(n)", "O(n²)", "O(2^n)"],
      "correctAnswer": 1,
      "explanation": "Although time complexity is O(2^n), space complexity is O(n) due to the maximum depth of the recursion call stack.",
      "type": "complexity",
      "language": "python",
      "difficulty": "hard",
      "points": 30,
      "timeLimit": 30,
      "category": "Algorithm Complexity"
    }
  ]
}